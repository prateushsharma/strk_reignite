from lynq.tool_definitons import Tool
from lynq.agent_definitions import Agent
from lynq.prompts import get_prompt
from groq import AsyncGroq

def fetch_data(tool_name: str) -> dict:
    """Fetch complete tool configuration as JSON-style dictionary
    
    Args:
        tool_name: Name of the tool to retrieve
        
    Returns:
        Dictionary containing all tool metadata with keys matching the schema
        
    Raises:
        ValueError: If tool doesn't exist
    """
    tool = Tool.get_tool(tool_name)
    if not tool:
        raise ValueError(f"Tool '{tool_name}' not found")
        
    return {
        "name": tool.schema["name"],
        "description": tool.schema["description"],
        "params": [
            {"name": p[0], "type": p[1].__name__, "required": p[2]}
            for p in tool.schema["params"]
        ],
        "returns": [t.__name__ for t in tool.schema["returns"]],
        "type": tool.schema["type"],
        "examples": tool.schema["examples"]
    }


def fetch_agent(agent_name: str) -> dict:
    """Fetch complete agent configuration as JSON-style dictionary
    
    Args:
        agent_name: Name of the registered agent
        
    Returns:
        {
            "name": str,
            "description": str,
            "backstory": str,
            "goal": str,
            "tool_access": list[str],
            "agent_access": list[str],
            "api_key": str,  # Consider security implications
            "self_loop": bool
        }
        
    Raises:
        ValueError: If agent doesn't exist
    """
    agent = Agent.get(agent_name)
    if not agent:
        raise ValueError(f"Agent '{agent_name}' not found")
    
    return {
        "name": agent.name,
        "description": agent.description,
        "backstory": agent.backstory,
        "goal": agent.goal,
        "tool_access": agent.tool_access,
        "agent_access": agent.agent_access,
        "api_key": agent.api_key,  # Note: In production, you might want to mask this
        "self_loop": agent.self_loop
    }

import json

import json

async def print_agent_response(agent_name, response_str: str, verbose: bool = False):
    try:
        # Parse the response string into a dictionary
        response_data = json.loads(response_str)

        # Extract the individual components
        response = response_data.get("response", "")
        tools = response_data.get("tools", [])
        agent = response_data.get("agent", None)
        self_loop = response_data.get("self_loop", False)

        if verbose:
            print("=" * 200)
            print(f"Response generated by {agent_name}: {response}")

            if tools:
                print("Agent has initiated tool access:")
                print("Tools accessed:")
                for tool in tools:
                    for tool_name, params in tool.items():
                        print(f"  Tool: {tool_name}")
                        for param, value in params.items():
                            print(f"    {param}: {value}")
            else:
                print("Agent did not initiate any tool access.")

            if self_loop:
                print("\nInitiating autonomous self-loopback sequence: the agent has requested recursive execution for iterative refinement.")

            if agent and agent != "":
                print(f"\nAgent has initiated Response Forwarding to {agent}")
                print(f"Data forwarding has been setup")

            print("=" * 200)
            print("\n\n\n")

        return response, tools, agent, self_loop

    except json.JSONDecodeError:
        if verbose:
            print("Error: The input string is not a valid JSON.")
        return None, [], None, False
    except Exception as e:
        if verbose:
            print(f"An unexpected error occurred: {e}")
        return None, [], None, False

async def generate_response(prompt, API_KEY):
    if not prompt or prompt == "":
        raise ValueError("Received Empty Prompt")
    
    client = AsyncGroq(api_key=API_KEY)
    chat_completion = await client.chat.completions.create(
        model="deepseek-r1-distill-llama-70b",
        messages=[
            {
                "role": "user",
                "content": prompt
            }
        ],
        temperature=0.6,
        max_completion_tokens=4096,
        top_p=0.95,
        stream=False,
        reasoning_format="parsed",
        response_format={"type": "json_object"}
    )

    response_content = chat_completion.choices[0].message.content
    return response_content

async def run_agent(query: str, agent_name: str, verbose: bool = False):

    print(f"\n\n\nRunning CMIT Process!!\nInitialised Agent: {agent_name}...\nProcessing...\n\n")

    final_response = ""
    # execution_logs = []
    data_collected = ""
    agent_data = fetch_agent(agent_name)
    api_key = agent_data["api_key"]
    first_prompt = get_prompt(agent=agent_name, query=query, data="")
    first_response = await generate_response(first_prompt, api_key)
    response, tools, agent, self_loop = await print_agent_response(agent_name, first_response, verbose=verbose)
    while self_loop or agent != None:
        for tool in tools:
            for tool_name, params in tool.items():
                apply_tool = Tool.get_tool(tool_name)
                if not apply_tool:
                    raise ValueError(f"Tool '{tool_name}' not found")
                result = await apply_tool.func(**params)
                log_entry = (
                    f"{tool_name} \non execution with parameters {params} returned \noutput: {result}"
                )
                # execution_logs.append(log_entry)
                if verbose:
                    print("=" * 200)
                    print(log_entry)
                    print("=" * 200)
                    print("\n\n\n")
                data_collected += f"\n{log_entry}\n"
        previous_response = "The agents had responded with this earlier:\n" + response + "\n"
        data_collected = previous_response + data_collected
        new_agent_name = agent_name if self_loop else agent
        new_agent_data = fetch_agent(new_agent_name)
        new_api_key = new_agent_data["api_key"]
        prompt = get_prompt(agent=new_agent_name, query=query, data=data_collected)
        response = await generate_response(prompt, new_api_key)
        response, tools, agent, self_loop = await print_agent_response(new_agent_name, response, verbose=verbose)
        if not self_loop and agent == None:
            final_response = response
            break
    if verbose:
        print("The agents have completed their task and returned the final response\n\n\n\n")
    return final_response